# 作用域
## 什么是作用域
> `作用域`是根据`名称`查找`变量`的**一套规则**。  
> 有两种工作模型：`词法作用域`和`动态作用域`

**作用域是怎么工作的?**
1. `收集`并`维护`代码中`声明的变量`
2. 使用`一套规则`，确定`当前执行的代码`对这些`变量`的`访问权限`

<!-- **例**： var a = 1;
1. 检查`作用域`中是否有`变量a`，存在就跳过继续编译，不存在要求作用域创建`变量a`
2. 编译器为引擎生成运行时所需的代码，用来处理a = 2 这个操作
3. 引擎运行询问作用域，是否有a，有直接用，并将2赋值给a；没有继续找，找不到抛出异常 -->

## 作用域嵌套
> 一个`块或函数`放在另一个`块或函数`中时，就是作用域嵌套。

**作用域嵌套时，怎么查找变量？**
+ 在自己`当前作用域`中查找
  + 找到：结束
  + **没找到**：到`外层作用域`查找，直到`全局作用域`（最外层）为止
    + 找到： 结束
    + **没找到**：会有两种情况，`创建变量`或`报错`。[具体查看 `LHS`和`RHS`](#lhs-和-rhs)

## LHS 和 RHS
### LHS
> 可简单理解为`等号左边`变量的取值操作。

**目的是**：找到变量的容器（指针）  
**属于**：`赋值`操作

`非严格模式`，找不到该变量会在`全局作用域`创建一个。  
`严格模式`，找不到会报错。

### RHS
> 可简单理解为`等号右边`变量的取值操作。

**目的是**：找到变量的值（源值）  
**属于**：`取值`操作

找不到抛`ReferenceError`异常。

    ReferenceError 与作用域判别失败相关。
    TypeError 表示作用域中存在，但对结果的操作是非法的。

## 遮蔽效应
> `作用域`会`从内往外`查找变量，找到`第一个匹配的变量`时停止，所以是**内部遮蔽外部**。  
> `多层嵌套`的`作用域`中定义`同名变量`，就会产生`遮蔽效应`

**全局变量被遮蔽还能访问吗？**
+ `全局变量`会自动成为`全局对象的属性`。
+ 因此可以通过`window.xx`(假设是浏览器环境)来访问`被遮蔽的全局变量`。
+ 非全局的变量被遮蔽了，就无法被访问了

## 欺骗词法
> 在`运行时`修改（欺骗）`词法作用域`。

### eval()
> `eval()`接受`一个字符串`作为参数，并将`字符串`在`运行时`当作`可执行代码`，并执行

```javascript
eval('var a = 1;'); // 运行在全局，会在全局对象上声明变量a
eval('console.log(a)'); // 打印2
```

`非严格模式`，`eval()`会`修改`所处的`词法作用域`。  
`严格模式`，`eval()`有自己的词法作用域，无法修改所处的作用域。

### with
> 重复引用修改同一个对象的多个属性的快捷方式。
> `严格模式`下不能使用with

``` javascript
// 修改obj值的两种方式
var obj = { num1: 0, num2: 1 };

// 方法一：重复调用
obj.num1 = 1; 
​obj.num2 = 2;

// 方法二：快捷方式
with (obj) {
  num1 = 1;
  num2 = 2;
  num3 = 3; // 因为会进行LHS查询，num3会被泄漏到全局作用域！！！
​}
```
+ 若with引用的属性在原对象中`存在`，则直接赋值。
+ 若with引用的属性在原对象中`不存在`，进行[LHS查询](#lhs)，来进行赋值。



### 性能问题
`eval()`和`with`会在`运行时`修改或创建`新的作用域`。引擎会在`编译阶段`会对代码进行`静态分析`（是的js也有编译阶段，在运行时进行），确定`变量`和`函数`的位置，方便在`执行过程中`快速找到变量和函数。如果在代码中发现`eval()`或`with`，将导致静态分析不准，此时就会`放弃进行静态分析`。若代码大量存在`eval()`和`with`，将导致代码运行变慢。




     

