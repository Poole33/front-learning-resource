# Promise
讲到`Promise`就不得不比较一下`回调函数`和`Promise`的区别和关系。  
`JS`实现`异步`最常用的方式就是使用`回调函数`，`Promise`是`ES6`中才引入的概念，他主要是为了解决`回调函数`存在的一些问题，可以看作`回调函数`的升级版。  
那`回调函数`中存在什么问题，和`Promise`又有什么区别呢？

## 回调函数的问题

### 1. 信任问题
  假设你去奶茶店买`珍珠奶茶`，你觉得珍珠不够多，想加一份珍珠。于是你跟店员说我加一份珍珠（假设这是一个异步函数，在奶茶做好后执行），然后服务员帮你做好标记，你付好钱之后，就等着开心的喝奶茶了。大部分情况下，我们是可以愉快的获得一份加了珍珠的珍珠奶茶的，但有时也会有忘记加的情况（别问我为什么知道，怨念..），这就是回调函数可能存在的信任问题，你不能确定你的回调函数会如何执行，执行几次，以及会不会执行。  
  ```javascript
  // 伪代码
  function buyMilkTea() {
    // 制作奶茶，接收一个加料回调
    doMilkTea(addSubject);

    // 加料
    addSubject() {
      // 加一份珍珠
    }
  }
  ```

  **`Promise`是如何解决信任问题的呢？**
  Promise和回调函数不同，他是通过分离回调（一个成功通知，一个错误通知），告诉你他完成了（只会告诉一次），接下来要执行什么，你自己来决定。  
  还是买奶茶的例子，你付好钱，等待叫号。会有两种结果：
  1. 叫到你的号，奶茶做好了（成功通知）。这时你可以告诉服务员帮我加一份珍珠（此时执行回调）
  2. 叫到你的号，但是因为原料不足，你的奶茶做不出来（失败通知）。这时你可以选择换一个品类，或者退钱

  ```javascript
  // 伪代码
  new Promise((resolve, reject) => {
    buyMilkTea();
    resolve(); // 通知叫号
  }).then(
    res => { // 成功回调
      addSubject(); // 加一份珍珠 
    },
    error => { // 失败回调
      // 退钱
    }
  )
  ```


### 2. 回调地狱